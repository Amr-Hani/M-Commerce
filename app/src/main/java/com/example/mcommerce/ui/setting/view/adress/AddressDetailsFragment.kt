package com.example.mcommerce.ui.setting.view.adress

import android.os.Bundle
import android.util.Log
import androidx.fragment.app.Fragment
import android.view.LayoutInflater
import android.view.View
import android.view.ViewGroup
import android.widget.Toast
import androidx.lifecycle.ViewModelProvider
import androidx.lifecycle.lifecycleScope
import androidx.navigation.fragment.findNavController
import com.example.mcommerce.R
import com.example.mcommerce.databinding.FragmentAddressDetailsBinding
import com.example.mcommerce.model.network.ApiState
import com.example.mcommerce.model.network.ProductInfoRetrofit
import com.example.mcommerce.model.network.RemoteDataSource
import com.example.mcommerce.model.network.Repository
import com.example.mcommerce.model.responses.Address
import com.example.mcommerce.model.responses.CustomerAddress
import com.example.mcommerceapp.ui.setting.veiwmodel.SettingViewModel
import com.example.mcommerceapp.ui.setting.veiwmodel.SettingViewModelFactory
import kotlinx.coroutines.flow.collectLatest
import kotlinx.coroutines.launch

class AddressDetailsFragment : Fragment() {

    private lateinit var binding: FragmentAddressDetailsBinding
    private lateinit var settingViewModel: SettingViewModel
    val customerId = 8229253710128
    override fun onCreateView(
        inflater: LayoutInflater, container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View? {
        binding = FragmentAddressDetailsBinding.inflate(inflater, container, false)

        setupViewModel()
        observeViewModel()


        arguments?.let { bundle ->
            val city = bundle.getString("city")
            val country = bundle.getString("country")
            val address = bundle.getString("address")

            binding.editTextCity.setText(city)
            binding.editTextCountry.setText(country)
            binding.editTextAddress.setText(address)
        }

        binding.buttonAddAddress.setOnClickListener {
            saveAddressData()
        }

        binding.imageButtonNavigateToMap.setOnClickListener {
            findNavController().navigate(R.id.action_addressDetailsFragment_to_mapsFragment)
        }

        return binding.root
    }

    private fun setupViewModel() {
        val factory = SettingViewModelFactory(
            Repository.getInstance(
                RemoteDataSource(ProductInfoRetrofit.productService)
            )
        )
        settingViewModel = ViewModelProvider(this, factory)[SettingViewModel::class.java]
    }

    private fun observeViewModel() {
        // Collect StateFlow in a lifecycle-aware way
        viewLifecycleOwner.lifecycleScope.launch {
            settingViewModel.addressState.collectLatest { state ->
                handleState(state)
            }
        }
    }

    private fun handleState(state: ApiState<List<Address>>) {
        when (state) {

            is ApiState.Loading -> {
                Toast.makeText(requireContext(), "Loading", Toast.LENGTH_SHORT).show()
            }
            is ApiState.Success -> {
                Toast.makeText(requireContext(), "Address added successfully", Toast.LENGTH_SHORT).show()
                findNavController().popBackStack(R.id.addressFragment, false)
            }
            is ApiState.Failure -> {
                Toast.makeText(requireContext(), "Error: ${state.message}", Toast.LENGTH_SHORT).show()
            }
        }
    }
    private fun saveAddressData() {
        val country = binding.editTextCountry.text.toString().trim()
        val city = binding.editTextCity.text.toString().trim()
        val address = binding.editTextAddress.text.toString().trim()
        val phone = binding.editTextPhone.text.toString().trim()

        when {
            !isValidCountryOrCity(country) -> {
                binding.editTextCountry.error = "Enter a valid country name"
                return
            }
            !isValidCountryOrCity(city) -> {
                binding.editTextCity.error = "Enter a valid city name"
                return
            }
            !isValidAddress(address) -> {
                binding.editTextAddress.error = "Enter a valid address"
                return
            }
            !isValidPhone(phone) -> {
                binding.editTextPhone.error = "Enter a valid phone number"
                return
            }
            else -> {

                val newAddress = CustomerAddress(
                    id = 0,  // This might be 0 or a default value as ID will be generated by the API
                    customer_id = 8229253710128,   // Customer ID
                    first_name = "Mohamed",        // Optional first name
                    last_name = "Alaa",            // Optional last name
                    company = "",                   // Optional company name
                    address1 = address,      // Required primary address line
                    address2 = "",                  // Optional secondary address line
                    city = city,                 // Required city name
                    province = "Cairo",             // Required province/state name
                    country = country,              // Required country name
                    zip = "12345",                  // Required postal/zip code
                    phone = phone,           // Optional phone number
                    name = "Mohamed Alaa",          // Optional full name
                    province_code = "",             // Optional province code
                    country_code = "EG",            // Required country code
                    country_name = "Egypt",         // Required country name
                    default = true                 // Indicates this is not the default address
                )
                settingViewModel.addAddress(customerId, newAddress)
                Log.d("response", "saveAddressData: {$customerId} ")
            }
        }
    }

    private fun isValidCountryOrCity(input: String): Boolean {
        return input.length > 1 && !input.matches(Regex("^[a-zA-Z]{1}$"))
    }

    private fun isValidAddress(address: String): Boolean {
        return address.length > 3
    }
    private fun isValidPhone(phone: String): Boolean {
        return phone.matches(Regex("^01[0125][0-9]{8}$"))
    }
}